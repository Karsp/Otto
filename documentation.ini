Documentation


/* ········································································································································· */
/* :                                                                                                                                       : */
/* :                                                                                                                                       : */
/* :                                                                                                                                       : */
/* :               _____                    _____                    _____                    _____                    _____               : */
/* :              /\    \                  /\    \                  /\    \                  /\    \                  /\    \              : */
/* :             /::\____\                /::\    \                /::\    \                /::\    \                /::\    \             : */
/* :            /:::/    /               /::::\    \              /::::\    \              /::::\    \              /::::\    \            : */
/* :           /:::/    /               /::::::\    \            /::::::\    \            /::::::\    \            /::::::\    \           : */
/* :          /:::/    /               /:::/\:::\    \          /:::/\:::\    \          /:::/\:::\    \          /:::/\:::\    \          : */
/* :         /:::/____/               /:::/__\:::\    \        /:::/__\:::\    \        /:::/__\:::\    \        /:::/__\:::\    \         : */
/* :        /::::\    \              /::::\   \:::\    \      /::::\   \:::\    \       \:::\   \:::\    \      /::::\   \:::\    \        : */
/* :       /::::::\____\________    /::::::\   \:::\    \    /::::::\   \:::\    \    ___\:::\   \:::\    \    /::::::\   \:::\    \       : */
/* :      /:::/\:::::::::::\    \  /:::/\:::\   \:::\    \  /:::/\:::\   \:::\____\  /\   \:::\   \:::\    \  /:::/\:::\   \:::\____\      : */
/* :     /:::/  |:::::::::::\____\/:::/  \:::\   \:::\____\/:::/  \:::\   \:::|    |/::\   \:::\   \:::\____\/:::/  \:::\   \:::|    |     : */
/* :     \::/   |::|~~~|~~~~~     \::/    \:::\  /:::/    /\::/   |::::\  /:::|____|\:::\   \:::\   \::/    /\::/    \:::\  /:::|____|     : */
/* :      \/____|::|   |           \/____/ \:::\/:::/    /  \/____|:::::\/:::/    /  \:::\   \:::\   \/____/  \/_____/\:::\/:::/    /      : */
/* :            |::|   |                    \::::::/    /         |:::::::::/    /    \:::\   \:::\    \               \::::::/    /       : */
/* :            |::|   |                     \::::/    /          |::|\::::/    /      \:::\   \:::\____\               \::::/    /        : */
/* :            |::|   |                     /:::/    /           |::| \::/____/        \:::\  /:::/    /                \::/____/         : */
/* :            |::|   |                    /:::/    /            |::|  ~|               \:::\/:::/    /                  ~~               : */
/* :            |::|   |                   /:::/    /             |::|   |                \::::::/    /                                    : */
/* :            \::|   |                  /:::/    /              \::|   |                 \::::/    /                                     : */
/* :             \:|   |                  \::/    /                \:|   |                  \::/    /                                      : */
/* :              \|___|                   \/____/                  \|___|                   \/____/                                       : */
/* :                                                                                                                                       : */
/* :                                                                                                                                       : */
/* :                                                                                                                                       : */
/* ········································································································································· */


I'm going to show you an example of how the block code is inserted in Python. I will explain what the code should do and how it is coded with blocks.
Could you please provide concise documentation of this code? This should cover teaching you how to start a new project, configure the components and call them as a block.

test 1

How does this code work?

1. First, make a sound to check if the buzzer is working.

2. See a sequence of colors at the top to make sure the ring is okay.

3. Test the left and right motors to see if they are moving as expected.

4. Now, keep doing the following in a loop:

- If something gets too close (within 10cm), turn on red lights.


import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from ottobuzzer import OttoBuzzer
from ottomotor import OttoMotor
from neopixel import NeoPixel
from ottoneopixel import OttoNeoPixel
from ottoneopixel import OttoUltrasonic
import utime

buzzer = OttoBuzzer(25)               # Built in Buzzer
motor = OttoMotor(13, 14)             # Connectors 10 & 11
bright = 0.8                          # brightness variable for lights
n = 13                                # Number of LEDs in ring
ring = OttoNeoPixel(4, n)             # Connector 5
ultrasonic = OttoUltrasonic(18, 19)

buzzer.playEmoji("S_connection")
ring.rainbow_cycle(n, 2)
ultrasonic.ultrasonicRGB1("00ff00", "00ff00")
motor.Moveleft(-1, 1, 1)
motor.Moveright(-1, 1, 1)
while True:
    if (ultrasonic.readultrasonicRGB(1)) <= (10):
        ring.fillAllRGBRing("fe0000")
        buzzer.playEmoji("S_surprise")
    else:
        ring.fillAllRGBRing("33ff33")


test 2
Motion with wheels

import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from ottomotor import OttoMotor
offset = 0

offset = 0
motor = OttoMotor(13, 14)             # Connectors 10 & 11

motor.leftServo.freq(50)
motor.rightServo.freq(50)
motor.leftServo.duty(109- offset)
motor.rightServo.duty(43+ offset)
sleep(1)
motor.rightServo.duty(0)
motor.leftServo.duty(0)
motor.rightServo.duty(45+ offset)
motor.leftServo.duty(45- offset)
sleep(0.4)
motor.rightServo.duty(0)
motor.leftServo.duty(0)
motor.leftServo.freq(50)
motor.rightServo.freq(50)
motor.leftServo.duty(43- offset)
motor.rightServo.duty(109+ offset)
sleep(1)
motor.rightServo.duty(0)
motor.leftServo.duty(0)
motor.rightServo.duty(115+ offset)
motor.leftServo.duty(115- offset)
sleep(0.4)
motor.rightServo.duty(0)
motor.leftServo.duty(0)


test 3
Sounds with buzzer

import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from ottobuzzer import OttoBuzzer
from ottomotor import OttoMotor

buzzer = OttoBuzzer(25)               # Built in Buzzer
motor = OttoMotor(13, 14)             # Connectors 10 & 11

buzzer.playEmoji("S_happy")
sleep((0.5))
buzzer.playNote(262, 125)
sleep((0.2))
buzzer.playNote(196, 125)
sleep((0.125))
buzzer.playNote(196, 125)
sleep((0.125))
buzzer.playNote(220, 125)
sleep((0.2))
buzzer.playNote(196, 125)
sleep((0.2))

test 3
Colorful lights with the RGB ring

import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from neopixel import NeoPixel
from ottoneopixel import OttoNeoPixel

bright = 0.8                          # brightness variable for lights
n = 13                                # Number of LEDs in ring
ring = OttoNeoPixel(4, n)             # Connector 5

ring.setBrightness((50/100))
ring.rainbow_cycle(n, 5)
ring.bounce(n, int(0 * bright), int(255 * bright), int(255 * bright), 150)
ring.cycle(n, int(0 * bright), int(255 * bright), int(255 * bright), 150)
ring.fillRGBRing("ffffff", "ff0101", "ff8000", "ffff00", "80ff00", "00ff00", "00ff80", "00ffff", "0080ff", "0000ff", "7f00ff", "ff00ff", "ff007f")



test 4
Colorful lights in the eyes

import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from ottoneopixel import OttoUltrasonic

ultrasonic = OttoUltrasonic(18, 19)

while True:
    ultrasonic.ultrasonicRGB1("3333ff", "fe0000")
    sleep((0.2))
    ultrasonic.ultrasonicRGB1("fe0000", "3333ff")
    sleep((0.2))



test 5
Distance sensor

import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from ottoneopixel import OttoUltrasonic

ultrasonic = OttoUltrasonic(18, 19)

while True:
    ultrasonic.ultrasonicRGB1("3333ff", "fe0000")
    sleep((0.2))
    ultrasonic.ultrasonicRGB1("fe0000", "3333ff")
    sleep((0.2))

test 6
Conditionals
Otto is clever! It can store values in variables to remember them,
and it can make decisions based on values using conditionals.

import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from ottoneopixel import OttoUltrasonic

ultrasonic = OttoUltrasonic(18, 19)

while True:
    ultrasonic.ultrasonicRGB1("3333ff", "fe0000")
    sleep((0.2))
    ultrasonic.ultrasonicRGB1("fe0000", "3333ff")
    sleep((0.2))


test 7
variables
What's a variable? It's a handy way to store any value you want your robot to remember. You can then use this value as you like.
In this example, we use a variable to remember how many times the ultrasound sensor measures a distance less than or equal to 10 cm.
Remember to open the console to see the values.

import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from neopixel import NeoPixel
from ottoneopixel import OttoNeoPixel

bright = 0.8                          # brightness variable for lights
n = 13                                # Number of LEDs in ring
ring = OttoNeoPixel(4, n)             # Connector 5

luz = 0
ring.setBrightness((20/100))
ring.clearRGB()
while True:
    for count in range((13)):
        ring.setRGBring(luz, "00ffff")
        luz += 1
        sleep((0.5))
        ring.clearRGB()
        print(luz)


    luz = 0

test 8
Avoid Obstacles
Making Otto avoid obstacles with his sensor like a smart robot will do, use the ultrasonic sensor to detect objects in front and then go away to avoid crashing into it


import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from ottoneopixel import OttoUltrasonic
import utime
from neopixel import NeoPixel
from ottoneopixel import OttoNeoPixel
from ottomotor import OttoMotor
offset = 0

ultrasonic = OttoUltrasonic(18, 19)
bright = 0.8                          # brightness variable for lights
n = 13                                # Number of LEDs in ring
ring = OttoNeoPixel(4, n)             # Connector 5
motor = OttoMotor(13, 14)             # Connectors 10 & 11

while True:
    if (ultrasonic.readultrasonicRGB(1)) < (10):
        ultrasonic.ultrasonicRGB1("fe0000", "fe0000")
        ring.fillAllRGBRing("fe0000")
        motor.leftServo.freq(50)
        motor.rightServo.freq(50)
        motor.leftServo.duty(43- offset)
        motor.rightServo.duty(109+ offset)
        sleep(1)
        motor.rightServo.duty(0)
        motor.leftServo.duty(0)
        motor.rightServo.duty(45+ offset)
        motor.leftServo.duty(45- offset)
        sleep(0.8)
        motor.rightServo.duty(0)
        motor.leftServo.duty(0)
    else:
        ultrasonic.ultrasonicRGB1("33ff33", "33ff33")
        ring.fillAllRGBRing("33ff33")
        motor.leftServo.duty(109- offset)
        motor.rightServo.duty(43+ offset)



test 9
Follow black line

Making Otto follow the line map included in the starter kit with the 2 line tracking sensors installed in the bottom of the robot, make sure to check digital vs analog connectors of IR sensor since they have separate connectors that go to different numbers in the main circuit board and should correspond to the selected block


import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from ottoneopixel import OttoUltrasonic
from ottomotor import OttoMotor
offset = 0

analogL=ADC(Pin(32))                  # Connector 6
analogR=ADC(Pin(33))                  # Connector 7
ultrasonic = OttoUltrasonic(18, 19)
motor = OttoMotor(13, 14)             # Connectors 10 & 11

while True:
    print("Left sensor value:")
    print(analogL.read())
    print("Right sensor value:")
    print(analogR.read())
    if (analogL.read()) > (800):
        ultrasonic.ultrasonicRGB1("fe0000", "00ff00")
        motor.leftServo.duty(60- offset)
        motor.rightServo.duty(60+ offset)
    elif (analogR.read()) > (800):
        ultrasonic.ultrasonicRGB1("00ff00", "fe0000")
        motor.leftServo.duty(95- offset)
        motor.rightServo.duty(95+ offset)
    else:
        ultrasonic.ultrasonicRGB1("00ff00", "00ff00")
        motor.leftServo.duty(95- offset)
        motor.rightServo.duty(60+ offset)

test 10
Functions

import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from neopixel import NeoPixel
from ottoneopixel import OttoNeoPixel

bright = 0.8                          # brightness variable for lights
n = 13                                # Number of LEDs in ring
ring = OttoNeoPixel(4, n)             # Connector 5

def colorWipe():
    global numberlights, delaytime, i, r
    for i in range(numberlights):
        ring.setRGBring(i, "33ff33")
        sleep(delaytime)



numberlights = 13
delaytime = 0.05
colorWipe()
for r in range((255)):
    for i in range(numberlights):
        ring.setRGBring(i, "33ff33")


    sleep(delaytime)



test 11
 Lights all

 import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from neopixel import NeoPixel
from ottoneopixel import OttoNeoPixel

bright = 0.8                          # brightness variable for lights
n = 13                                # Number of LEDs in ring
ring = OttoNeoPixel(4, n)             # Connector 5

def red():
    global i, numberleds, delay
    for i in range(numberleds):
        ring.setRGBLed(255, 0, 0, i)
        sleep(delay)



def green():
    global i, numberleds, delay
    for i in range(numberleds):
        ring.setRGBLed(0, 255, 0, i)
        sleep(delay)



def blue():
    global i, numberleds, delay
    for i in range(numberleds):
        ring.setRGBLed(0, 0, 255, i)
        sleep(delay)



def orange():
    global i, numberleds, delay
    for i in range(numberleds):
        ring.setRGBLed(255, 128, 0, i)
        sleep(delay)



def yellow():
    global i, numberleds, delay
    for i in range(numberleds):
        ring.setRGBLed(255, 255, 0, i)
        sleep(delay)



def lime():
    global i, numberleds, delay
    for i in range(numberleds):
        ring.setRGBLed(128, 255, 0, i)
        sleep(delay)



def spring():
    global i, numberleds, delay
    for i in range(numberleds):
        ring.setRGBLed(0, 255, 128, i)
        sleep(delay)



def cyan():
    global i, numberleds, delay
    for i in range(numberleds):
        ring.setRGBLed(0, 255, 255, i)
        sleep(delay)



def azure():
    global i, numberleds, delay
    for i in range(numberleds):
        ring.setRGBLed(0, 128, 255, i)
        sleep(delay)



def purple():
    global i, numberleds, delay
    for i in range(numberleds):
        ring.setRGBLed(128, 0, 255, i)
        sleep(delay)



def magenta():
    global i, numberleds, delay
    for i in range(numberleds):
        ring.setRGBLed(255, 0, 255, i)
        sleep(delay)



def rose():
    global i, numberleds, delay
    for i in range(numberleds):
        ring.setRGBLed(255, 0, 128, i)
        sleep(delay)



def white():
    global i, numberleds, delay
    for i in range(numberleds):
        ring.setRGBLed(255, 255, 255, i)
        sleep(delay)



ring.fillRGBRing("ffffff", "ff8000", "ffff00", "80ff00", "00ff00", "00ff80", "00ffff", "0080ff", "0000ff", "7f00ff", "ff00ff", "ff007f", "ff0101")
sleep((1))
while True:
    delay = (1) / (12)
    numberleds = 13
    red()
    orange()
    yellow()
    green()
    spring()
    cyan()
    azure()
    blue()
    purple()
    magenta()
    rose()
    white()


test 12
  Lights smooth

  from neopixel import NeoPixel
from ottoneopixel import OttoNeoPixel
import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes

bright = 0.8                          # brightness variable for lights
n = 13                                # Number of LEDs in ring
ring = OttoNeoPixel(4, n)             # Connector 5

def Wheel():
    global WheelPos, numberleds, L, i
    WheelPos = (255) - WheelPos
    if WheelPos < (85):
        for L in range(numberleds):
            ring.setRGBLed((255) - WheelPos * (3), 0, WheelPos * (3), L)


    elif WheelPos < (170):
        WheelPos -= 85
        for L in range(numberleds):
            ring.setRGBLed(0, WheelPos * (3), (255) - WheelPos * (3), L)


    else:
        WheelPos -= 170
        for L in range(numberleds):
            ring.setRGBLed(WheelPos * (3), (255) - WheelPos * (3), 0, L)



numberleds = 13
WheelPos = 0
for i in range((255)):
    WheelPos = i
    Wheel()
    sleep((0.05))


test 13
 Merry Christmas

 import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from neopixel import NeoPixel
from ottoneopixel import OttoNeoPixel
from ottoneopixel import OttoUltrasonic
from ottobuzzer import OttoBuzzer
from ottomotor import OttoMotor

bright = 0.8                          # brightness variable for lights
n = 13                                # Number of LEDs in ring
ring = OttoNeoPixel(4, n)             # Connector 5
ultrasonic = OttoUltrasonic(18, 19)
buzzer = OttoBuzzer(25)               # Built in Buzzer
motor = OttoMotor(13, 14)             # Connectors 10 & 11

ring.rainbow_cycle(n, 5)
ultrasonic.ultrasonicRGB1("00ff00", "00ff00")
buzzer.playNote(262, 250)
buzzer.playNote(349, 250)
sleep((0.2))
ring.fillAllRGBRing("fe0000")
buzzer.playNote(349, 250)
buzzer.playNote(392, 250)
buzzer.playNote(349, 250)
buzzer.playNote(329, 250)
buzzer.playNote(293, 250)
ultrasonic.ultrasonicRGB2(255, 0, 0)
sleep((0.2))
buzzer.playNote(294, 250)
sleep((0.2))
ultrasonic.ultrasonicRGB2(0, 255, 0)
buzzer.playNote(294, 250)
sleep((0.2))
buzzer.playNote(392, 250)
ultrasonic.ultrasonicRGB2(255, 0, 0)
sleep((0.2))
buzzer.playNote(392, 250)
buzzer.playNote(440, 250)
buzzer.playNote(392, 250)
buzzer.playNote(349, 250)
sleep((0.2))
buzzer.playNote(330, 250)
ultrasonic.ultrasonicRGB2(0, 255, 0)
buzzer.playNote(262, 250)
sleep((0.2))
buzzer.playNote(440, 250)
ultrasonic.ultrasonicRGB2(255, 0, 0)
sleep((0.2))
buzzer.playNote(440, 250)
sleep((0.2))
ultrasonic.ultrasonicRGB2(0, 255, 0)
buzzer.playNote(494, 250)
sleep((0.2))
buzzer.playNote(440, 250)
buzzer.playNote(392, 250)
buzzer.playNote(349, 250)
buzzer.playNote(293, 250)
buzzer.playNote(261, 250)
buzzer.playNote(261, 250)
buzzer.playNote(293, 250)
buzzer.playNote(392, 250)
ultrasonic.ultrasonicRGB2(255, 0, 0)
sleep((0.2))
buzzer.playNote(330, 250)
buzzer.playNote(349, 250)



test 14
Sumo

from ottoneopixel import OttoUltrasonic
import utime
from ottomotor import OttoMotor
offset = 0
import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes

ultrasonic = OttoUltrasonic(18, 19)
motor = OttoMotor(13, 14)             # Connectors 10 & 11

def search():
    global right_black, left_black
    while (ultrasonic.readultrasonicRGB(1)) > (15):
        motor.rightServo.duty(45+ offset)
        motor.leftServo.duty(45- offset)
        sleep(0.4)
        motor.rightServo.duty(0)
        motor.leftServo.duty(0)

    motor.Stop(1)

analogL=ADC(Pin(32))                  # Connector 6
analogR=ADC(Pin(33))                  # Connector 7

def takeout():
    global right_black, left_black
    while (analogL.read()) > left_black or (analogR.read()) > right_black:
        motor.leftServo.duty(109- offset)
        motor.rightServo.duty(43+ offset)

    motor.leftServo.freq(50)
    motor.rightServo.freq(50)
    motor.leftServo.duty(43- offset)
    motor.rightServo.duty(109+ offset)
    sleep(2)
    motor.rightServo.duty(0)
    motor.leftServo.duty(0)

right_black = 600
left_black = 700
search()
takeout()


test 15
Wifi

import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
import network
import ubinascii
import urequests
from ottoneopixel import OttoUltrasonic
import utime

def do_sta_connect():
 global sta_if
 sta_if = network.WLAN(network.STA_IF)
 if not sta_if.isconnected():
  sta_if.active(True)
  sta_if.connect("kfjg","*********")
 print("Connecting to network ...")
 while not sta_if.isconnected():
  pass
 print("Connected.The MAC address is: ", ubinascii.hexlify(sta_if.config('mac'), ':').decode().upper())
 print("The network values are: ", sta_if.ifconfig())

THINGSPEAK_API = 'xxxxxxxxxxxxxxx'
def make_thingspeak_request(field="field1",value=""):
 print("Connecting")
 response = urequests.post('http://api.thingspeak.com/update?api_key=' + THINGSPEAK_API + "&"+field+"="+str(value))
 print(response.text)
 print (response.status_code)
 response.close()
 print("Closing Connection")

ultrasonic = OttoUltrasonic(18, 19)

do_sta_connect()
while True:
    dist = ultrasonic.readultrasonicRGB(1)
    make_thingspeak_request('field1',dist)
    print(dist)
    sleep((20))



test 16
 Line follow sense

 import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from ottomotor import OttoMotor
from ottoneopixel import OttoUltrasonic
import utime
offset = 0

motor = OttoMotor(13, 14)             # Connectors 10 & 11
analogL=ADC(Pin(32))                  # Connector 6
analogR=ADC(Pin(33))                  # Connector 7
ultrasonic = OttoUltrasonic(18, 19)

while True:
    motor.Stop(1)
    lineSenseL = analogL.read()
    lineSenseR = analogR.read()
    print("Left sensor value:")
    print(lineSenseL)
    print("Right sensor value:")
    print(lineSenseR)
    distance = ultrasonic.readultrasonicRGB(1)
    if distance == (0):
        distance = 11
    print("Distance")
    print(distance)
    if distance < (10):
        ultrasonic.ultrasonicRGB1("fe0000", "fe0000")
        motor.leftServo.freq(50)
        motor.rightServo.freq(50)
        motor.leftServo.duty(43- offset)
        motor.rightServo.duty(109+ offset)
        sleep(0.2)
        motor.rightServo.duty(0)
        motor.leftServo.duty(0)
        motor.rightServo.duty(45+ offset)
        motor.leftServo.duty(45- offset)
        sleep(0.8)
        motor.rightServo.duty(0)
        motor.leftServo.duty(0)
    elif lineSenseL > (700):
        ultrasonic.ultrasonicRGB1("fe0000", "00ff00")
        motor.Stop(2)
        motor.Moveright(1, 0.05, 1)
        motor.Stop(1)
    elif lineSenseR > (700):
        ultrasonic.ultrasonicRGB1("00ff00", "fe0000")
        motor.Stop(3)
        motor.Moveleft(1, 0.05, 3)
        motor.Stop(1)
    else:
        ultrasonic.ultrasonicRGB1("00ff00", "00ff00")
        motor.leftServo.freq(50)
        motor.rightServo.freq(50)
        motor.leftServo.duty(95- offset)
        motor.rightServo.duty(60+ offset)
        sleep(0.1)
        motor.rightServo.duty(0)
        motor.leftServo.duty(0)

test 17
 Line lights


 import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from ottoneopixel import OttoUltrasonic

ultrasonic = OttoUltrasonic(18, 19)
digitalL = Pin(27, Pin.IN)            # Connector 8
digitalR = Pin(15, Pin.IN)            # Connector 9

while True:
    ultrasonic.ultrasonicRGB1("9999ff", "9999ff")
    if (digitalL.value()) == (1):
        ultrasonic.ultrasonicRGB1("fe0000", "ffff66")
    if (digitalR.value()) == (1):
        ultrasonic.ultrasonicRGB1("ffff66", "cc0000")

test 18
Sense kit - Sense temperature and humity

import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from ottosensors import DHT

d = DHT(26)

while True:
    print("temperature in C:")
    print(d.temperature())
    sleep((1))
    print("humidity %:")
    print(d.humidity())
    sleep((1))

test 19
Sense kit - Sense tilt

import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from ottobuzzer import OttoBuzzer
from ottomotor import OttoMotor
from ottoneopixel import OttoUltrasonic

digital_pin_26 = Pin(26, Pin.IN)
import random
buzzer = OttoBuzzer(25)               # Built in Buzzer
motor = OttoMotor(13, 14)             # Connectors 10 & 11
ultrasonic = OttoUltrasonic(18, 19)

tilt = 0
prev = digital_pin_26.value()
while True:
    curr = digital_pin_26.value()
    print(tilt)
    if prev == (0) and curr == (1):
        buzzer.playNote(random.randint(100, 800), 125)
        tilt += 5
    prev = curr
    if (255) < tilt:
        tilt = 0
    ultrasonic.ultrasonicRGB2(0, 0, tilt)


test 20
Sense kit - Sense light (luminocity)

import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from ottoneopixel import OttoUltrasonic

adc_33 = ADC(33)
adc_33.width(ADC.WIDTH_12BIT)
adc_33.atten(ADC.ATTN_6DB)
def light(value, in_min, in_max, out_min, out_max):
   light = (value - in_min) * (out_max - out_min) / (in_max - in_min) + out_min
   return light

ultrasonic = OttoUltrasonic(18, 19)

while True:
    print(int(light(adc_33.read(), 4095, 0, 0, 100)))
    if (int(light(adc_33.read(), 4095, 0, 0, 100))) <= (50):
        ultrasonic.ultrasonicRGB2(0, 0, 255)
    else:
        ultrasonic.clearultrasonicRGB()
    sleep((0.1))



test 21
Sense kit - Sense microphone

import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from ottobuzzer import OttoBuzzer
from ottomotor import OttoMotor

adc_32 = ADC(32)
adc_32.width(ADC.WIDTH_12BIT)
adc_32.atten(ADC.ATTN_11DB)
def sound(value, in_min, in_max, out_min, out_max):
   sound = (value - in_min) * (out_max - out_min) / (in_max - in_min) + out_min
   return sound

buzzer = OttoBuzzer(25)               # Built in Buzzer
motor = OttoMotor(13, 14)             # Connectors 10 & 11

while True:
    print(int(sound(adc_32.read(), 0, 4095, 0, 100)))
    if (int(sound(adc_32.read(), 0, 4095, 0, 100))) <= (50):
        buzzer.execute_RTTTL('A-Team')
    else:
        buzzer.playNote(0,0)
    sleep((0.1))

test 22
Interact kit - interact button

import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from ottoneopixel import OttoUltrasonic
from ottobuzzer import OttoBuzzer
from ottomotor import OttoMotor

digital_pin_26 = Pin(26, Pin.IN)
led = Pin(2, Pin.OUT)                 # Built in LED
ultrasonic = OttoUltrasonic(18, 19)
buzzer = OttoBuzzer(25)               # Built in Buzzer
motor = OttoMotor(13, 14)             # Connectors 10 & 11

while True:
    if (digital_pin_26.value()) == (0):
        led.on()
        ultrasonic.ultrasonicRGB2(0, 255, 0)
        buzzer.playEmoji("S_happy")
    else:
        ultrasonic.ultrasonicRGB2(255, 0, 0)
        led.off()


test 23
Interact kit - Interact potentiometer

import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from ottobuzzer import OttoBuzzer
from ottomotor import OttoMotor

adc_33 = ADC(33)
adc_33.width(ADC.WIDTH_12BIT)
adc_33.atten(ADC.ATTN_11DB)
def pot(value, in_min, in_max, out_min, out_max):
   pot = (value - in_min) * (out_max - out_min) / (in_max - in_min) + out_min
   return pot

import math

def map(value, in_min, in_max, out_min, out_max):
   map = (value - in_min) * (out_max - out_min) / (in_max - in_min) + out_min
   return map

buzzer = OttoBuzzer(25)               # Built in Buzzer
motor = OttoMotor(13, 14)             # Connectors 10 & 11

while True:
    print(int(pot(adc_33.read(), 4095, 0, 0, 270)))
    buzzer.playNote(round(map(int(pot(adc_33.read(), 4095, 0, 0, 270)), 0, 270, 260, 525)), 125)

test 24
Interact kit - interact encoder

import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from ottosensors import RotaryIRQ
from ottoneopixel import OttoUltrasonic

encoder=RotaryIRQ(pin_num_clk=17,pin_num_dt=16,min_val=0,max_val=1000,reverse=True,range_mode=RotaryIRQ.RANGE_UNBOUNDED)
ultrasonic = OttoUltrasonic(18, 19)

encoder.set(value=0)
while True:
    print(encoder.value())
    if (encoder.value()) >= (6) or (encoder.value()) <= (-1):
        encoder.set(value=0)
    ultrasonic.clearultrasonicRGB()
    ultrasonic.setultrasonicRGBLed2(0, 0, 255, encoder.value())
    sleep((0.1))



test 25
Interact kit - Interact accelerometer

import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from adxl345 import ADXL345
from machine import Pin, SoftI2C

i2c = SoftI2C(scl=Pin(22), sda=Pin(21)) #Connector 3
accel = ADXL345(i2c)

x, y, z = accel.ReadXYZ()
print("X: ")
print("{}".format(x))
print("Y: ")
print("{}".format(y))
print("Z: ")
print("{}".format(z))



test 26
Emote kit - Display on rgb matrix

import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from neopixel import NeoPixel
nm = 64   # Number of LEDs in matrix
matrix = NeoPixel(Pin(22), nm)
brightm = 0.2 # brightness variable for matrix lights

def draw(bits,r=0, g=0, b=0):
   for i, bit in enumerate(bits):
       if bit == '1':
           matrix[i] = (r, g, b)
   matrix.write()
   sleep(0.01)

draw("1111111111111111111111111111111111111111111111111111111111111111",50,0,0)
sleep((1))
draw("1111111111111111111111111111111111111111111111111111111111111111",0,50,0)
sleep((1))
draw("1111111111111111111111111111111111111111111111111111111111111111",0,0,50)
sleep((1))
draw("1111111111111111111111111111111111111111111111111111111111111111",50,50,0)
sleep((1))
draw("1111111111111111111111111111111111111111111111111111111111111111",0,50,50)
sleep((1))
draw("1111111111111111111111111111111111111111111111111111111111111111",50,0,50)
sleep((1))
draw("1111111111111111111111111111111111111111111111111111111111111111",25,0,50)
sleep((1))
draw("1111111111111111111111111111111111111111111111111111111111111111",50,25,0)
sleep((1))
draw("1111111111111111111111111111111111111111111111111111111111111111",50,50,50)
sleep((1))
draw("1111111111111111111111111111111111111111111111111111111111111111",0,0,0)

test 27
Emote kit - Emojis

import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from neopixel import NeoPixel
nm = 64   # Number of LEDs in matrix
matrix = NeoPixel(Pin(22), nm)
brightm = 0.2 # brightness variable for matrix lights

def draw(bits,r=0, g=0, b=0):
   for i, bit in enumerate(bits):
       if bit == '1':
           matrix[i] = (r, g, b)
   matrix.write()
   sleep(0.01)

def fire():
    draw("0001010010010000001001010110101010100011100000011000000101000010",50,0,0)
    draw("0000000000000000000100000001010001011110011111100111111000111100",50,25,0)
    draw("0000000000000000000000000000000000000000000110000001100000000000",50,50,0)

def tree():
    draw("0001100000111100001111000111111001111110111111111111111100000000",0,50,0)
    draw("0000000000000000000000000000000000000000000000000000000000011000",50,50,50)
    draw("0000100000000000000100000000100000000100000000000010000000000000",50,0,0)
    draw("0000000000000000000010000000000000100000000001000000000000000000",0,0,50)
    draw("0000000000101000000000000001000000000000010100000000001000000000",50,50,0)

def dominicana():
    draw("0000011100000111000001110000100000010000111000001110000011100000",50,0,0)
    draw("1110000011100000111000000001000000001000000001110000011100000111",0,0,50)
    draw("0001100000011000000110001110011111100111000110000001100000011000",50,50,50)

def robot():
    draw("0000000001111110011111100111111001111110011111100111111001111110",0,25,50)
    draw("0000000000000000011001100110011000000000001111000011110000000000",int(255 * brightm), int(255 * brightm), int(255 * brightm))
    draw("1001100110000001100000011000000110000001100000011000000100000000",50,0,0)

def snow():
    draw("0001100001111110111111111111111111111111111111110111111000111100",50,50,50)
    draw("0011110000000000000000000000000000000000000000000000000000000000",50,0,25)
    draw("0000000000000000001001000010010000000000000000000000000000000000",0,0,50)
    draw("0000000000000000000000000000000000011000000110000000000000000000",50,25,0)
    draw("0000000000000000000000000000000000000000000000000000000000110000",50,0,0)
    draw("0000000000000000000000000000000000000000000000000000000000001100",0,50,0)

def surprise():
    draw("0111111011111111111111111111111111111111111111111111111101111110",50,50,0)
    draw("0000000000000000001001000010010000000000000110000001100000000000",int(0 * brightm), int(0 * brightm), int(0 * brightm))
    draw("0000000000000000000000000000000000000000000000000001100000000000",50,0,0)
    draw("0000000000000000000000000010010000000000000000000000000000000000",0,0,50)

def love():
    draw("0111111011111111111111111111111111111111111111111111111101111110",50,50,0)
    draw("0000000010100101111001110100001000000000000000000000000000000000",50,0,0)
    draw("0000000000000000000000000000000000000000001111000000000000000000",int(0 * brightm), int(0 * brightm), int(0 * brightm))
    draw("0000000000000000000000000000000000000000000000000001100000000000",50,0,25)

def star():
    draw("0111111011111111111111111111111111111111111111111111111101111110",50,50,0)
    draw("0000000000000000000000000000000000000000011111100011110000000000",int(0 * brightm), int(0 * brightm), int(0 * brightm))
    draw("0000000010100101010000101010010100000000000000000001100000000000",50,0,0)

star()
sleep((3))
matrix.fill((0,0,0))
matrix.write()
surprise()
sleep((3))
matrix.fill((0,0,0))
matrix.write()
love()
sleep((3))
matrix.fill((0,0,0))
matrix.write()
robot()
sleep((3))
matrix.fill((0,0,0))
matrix.write()
snow()
sleep((3))
matrix.fill((0,0,0))
matrix.write()
tree()
sleep((3))
matrix.fill((0,0,0))
matrix.write()
fire()
sleep((3))
matrix.fill((0,0,0))
matrix.write()
dominicana()
sleep((3))
matrix.fill((0,0,0))
matrix.write()

test 28
Emote kit - OLED Display

import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from ssd1306 import SSD1306_I2C
i2c = SoftI2C(sda=Pin(19), scl=Pin(18))
oled = SSD1306_I2C(128, 64, i2c)
import array # Needed for polygons


def oled_eyesclosed():
   oled.rect(16,0,96,33,0,True)
   oled.rect(16,16,32,6,1,True)
   oled.rect(80,16,32,6,1,True)
def oled_eyes():
   oled.rect(16,0,96,33,0,True)
   oled.ellipse(32,16,16,16,1,1)
   oled.ellipse(32,16,10,10,0,1)
   oled.ellipse(96,16,16,16,1,1)
   oled.ellipse(96,16,10,10,0,1)
def oled_eyesup():
   oled_eyes()
   oled.rect(0,16,128,17,0,True)
def oled_eyesup2():
   oled.rect(16,0,96,33,0,True)
   oled.ellipse(32,32,16,16,1,1)
   oled.ellipse(32,32,10,10,0,1)
   oled.ellipse(96,32,16,16,1,1)
   oled.ellipse(96,32,10,10,0,1)
   oled.rect(0,32,128,17,0,True)
def oled_eyesdown():
   oled_eyes()
   oled.rect(0,0,128,16,0,True)
def oled_eyesdown2():
   oled.rect(16,0,96,33,0,True)
   oled.ellipse(32,0,16,16,1,1)
   oled.ellipse(32,0,10,10,0,1)
   oled.ellipse(96,0,16,16,1,1)
   oled.ellipse(96,0,10,10,0,1)
def oled_eyeswinkleft():
   oled_eyes()
   oled.rect(64,0,128,16,0,True)
def oled_eyeswinkright():
   oled_eyes()
   oled.rect(0,0,64,16,0,True)
def oled_eyesangry():
   oled_eyes()
   triangle1 = array.array('I', [16,0,48,0,48,32])
   oled.poly(0,0, triangle1, 0, True)
   triangle2 = array.array('I', [80,0,112,0,80,32])
   oled.poly(0,0, triangle2, 0, True)
def oled_eyesworry():
   oled_eyes()
   triangle1 = array.array('I', [16,0,48,0,16,32])
   oled.poly(0,0, triangle1, 0, True)
   triangle2 = array.array('I', [80,0,112,0,112,32])
   oled.poly(0,0, triangle2, 0, True)


def oled_mouthclosed():
   oled.rect(32,32,64,32,0,True)
   oled.rect(32,42,64,6,1,True)
def oled_mouth():
   oled.rect(32,32,64,32,0,True)
   oled.ellipse(64,48,16,16,1,1)
   oled.ellipse(64,48,10,10,0,1)
def oled_mouthup():
   oled_mouth()
   oled.rect(48,32,33,16,0,True)
def oled_mouthup2():
   oled.rect(32,32,64,32,0,True)
   oled.ellipse(64,32,16,16,1,1)
   oled.ellipse(64,32,10,10,0,1)
   oled.rect(48,16,33,16,0,True)
def oled_mouthdown():
   oled_mouth()
   oled.rect(48,48,33,16,0,True)
def oled_mouthdown2():
   oled.rect(32,32,64,32,0,True)
   oled.ellipse(64,64,16,16,1,1)
   oled.ellipse(64,64,10,10,0,1)
def oled_mouthleft():
   oled_mouthclosed()
   oled.ellipse(80,53,15,11,1,1)
   oled.rect(64,48,32,5,1,True)
def oled_mouthright():
   oled_mouthclosed()
   oled.ellipse(48,53,15,11,1,1)
   oled.rect(32,48,32,5,1,True)
def oled_mouthhappy():
   oled.rect(32,32,64,32,0,True)
   oled.ellipse(64,48,15,15,1,1)
   oled.rect(48,32,32,16,1,True)
def oled_mouthworry():
   oled.rect(32,32,64,32,0,True)
   oled.ellipse(64,48,15,10,1,1)

oled.text("{}".format("Hello Otto! "), 0, 0,1)
oled.show()
sleep((1))
oled.pixel(1, 0, 1)
oled.line(0, 0, 128, 64,1)
oled.rect(0,0,128,64,1,1)
oled.ellipse(0, 32, 32,32,1,1)
oled.ellipse(64,32,32,16,1,1)
oled.show()
sleep((1))
while True:
    oled.fill(0)
    oled_eyes()
    oled.show()
    oled_mouth()
    oled.show()
    oled.show()
    sleep((1))
    oled.fill(0)
    oled_eyesup()
    oled.show()
    oled_mouthup()
    oled.show()
    oled.show()
    sleep((1))
    oled.fill(0)
    oled_eyesup2()
    oled.show()
    oled_mouthup2()
    oled.show()
    oled.show()
    sleep((1))
    oled.fill(0)
    oled_eyesdown2()
    oled.show()
    oled_mouthdown2()
    oled.show()
    oled.show()
    sleep((1))
    oled.fill(0)
    oled_eyesdown()
    oled.show()
    oled_mouthdown()
    oled.show()
    oled.show()
    sleep((1))
    oled.fill(0)
    oled_eyesworry()
    oled.show()
    oled_mouthworry()
    oled.show()
    oled.show()
    sleep((1))

test 29
Emote kit - mp3

import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from ottoneopixel import OttoUltrasonic
from ottobuzzer import Player
dfplayer = Player(16, 17)
from neopixel import NeoPixel
nm = 64   # Number of LEDs in matrix
matrix = NeoPixel(Pin(22), 64)
brightm = 0.2 # brightness variable for matrix lights

ultrasonic = OttoUltrasonic(18, 19)
dfplayer = Player(16, 17)

def draw(bits,r=0, g=0, b=0):
   for i, bit in enumerate(bits):
       if bit == '1':
           matrix[i] = (r, g, b)
   matrix.write()
   sleep(0.01)

def pixel(row, col, r=0, g=0, b=0, color=''):
   if color == '':
       matrix[col + (row*8)] = (r, g, b)
       matrix.write()
   else:
       matrix[col + (row*8)] = self.color
       matrix.write();

ultrasonic.ultrasonicRGB2(0, 0, 255)
dfplayer.volume(round(50/2))
dfplayer.volume_up()
dfplayer.play()
draw("0000000001100110011001100000000010000001010000100011110000000000",0,50,0)
sleep((2))
dfplayer.play('next')
matrix.fill((0,0,0))
matrix.write()
for count in range((10)):
    dfplayer.play('next')
    ultrasonic.setultrasonicRGBEye(0, 0, 0, 1)
    for i in range((8)):
        pixel(i, i, 255,0,0)
        sleep((0.1))


    matrix.fill((0,0,0))
    matrix.write()
    ultrasonic.setultrasonicRGBEye(0, 0, 255, 1)
    sleep((1))

test 30
 Invent Walk&Roll Align legs

 import machine, time                       #importing machine and time libraries
from time import sleep                     #importing sleep class
from machine import Pin, ADC, PWM, SoftI2C #importing classes
from ottowalkroll import Ninja

ninja = Ninja(27, 15, 14, 13) # Connector 8 (Left leg), 9(Right leg), 10(Left foot), 11(Right foot)

ninja.walkset()
